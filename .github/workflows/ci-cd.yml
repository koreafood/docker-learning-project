name: CI/CD Pipeline with Self-hosted Runner

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'development'
        type: choice
        options:
        - development
        - staging
        - production

env:
  DOCKER_IMAGE_NAME: docker-hello-app
  DOCKER_REGISTRY: localhost:5000
  NODE_VERSION: '18'

jobs:
  # 코드 품질 검사 및 테스트
  test:
    name: 🧪 Test and Quality Check
    runs-on: self-hosted
    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4

      - name: 🟢 Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: 📦 Install dependencies
        run: |
          npm ci
          npm audit --audit-level=high

      - name: 🔍 Lint code
        run: |
          # ESLint 설정이 있다면 실행
          if [ -f ".eslintrc.js" ] || [ -f ".eslintrc.json" ]; then
            npm run lint
          else
            echo "ESLint configuration not found, skipping lint check"
          fi

      - name: 🧪 Run tests
        run: |
          # 테스트 스크립트가 있다면 실행
          if npm run | grep -q "test"; then
            npm test
          else
            echo "No test script found, creating basic health check"
            node -e "console.log('Application syntax check passed')"
          fi

      - name: 📊 Generate test coverage
        run: |
          if npm run | grep -q "coverage"; then
            npm run coverage
          else
            echo "No coverage script found, skipping coverage report"
          fi

  # Docker 이미지 빌드
  build:
    name: 🐳 Build Docker Image
    runs-on: self-hosted
    needs: test
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4

      - name: 🐳 Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: 🏷️ Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: 🔨 Build Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: false
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          outputs: type=docker,dest=/tmp/docker-image.tar

      - name: 📤 Upload Docker image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: /tmp/docker-image.tar
          retention-days: 1

  # 보안 스캔
  security-scan:
    name: 🔒 Security Scan
    runs-on: self-hosted
    needs: build
    steps:
      - name: 📥 Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp

      - name: 📥 Load Docker image
        run: docker load --input /tmp/docker-image.tar

      - name: 🔍 Run Trivy vulnerability scanner
        run: |
          # Trivy 설치 (없는 경우)
          if ! command -v trivy &> /dev/null; then
            sudo apt-get update
            sudo apt-get install wget apt-transport-https gnupg lsb-release
            wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
            echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
            sudo apt-get update
            sudo apt-get install trivy
          fi
          
          # 보안 스캔 실행
          trivy image --exit-code 0 --severity HIGH,CRITICAL ${{ env.DOCKER_IMAGE_NAME }}:latest

  # 개발 환경 배포
  deploy-dev:
    name: 🚀 Deploy to Development
    runs-on: self-hosted
    needs: [test, build, security-scan]
    if: github.ref == 'refs/heads/develop' || github.event_name == 'workflow_dispatch'
    environment:
      name: development
      url: http://localhost:3000
    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4

      - name: 📥 Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp

      - name: 📥 Load Docker image
        run: docker load --input /tmp/docker-image.tar

      - name: 🛑 Stop existing container
        run: |
          if docker ps -q --filter "name=docker-hello-app-dev" | grep -q .; then
            echo "Stopping existing development container..."
            docker stop docker-hello-app-dev
            docker rm docker-hello-app-dev
          fi

      - name: 🚀 Deploy to development
        run: |
          docker run -d \
            --name docker-hello-app-dev \
            --restart unless-stopped \
            -p 3000:3000 \
            -e NODE_ENV=development \
            -e PORT=3000 \
            ${{ env.DOCKER_IMAGE_NAME }}:latest

      - name: ⏳ Wait for application startup
        run: |
          echo "Waiting for application to start..."
          for i in {1..30}; do
            if curl -f http://localhost:3000 > /dev/null 2>&1; then
              echo "Application is ready!"
              break
            fi
            echo "Attempt $i: Application not ready yet, waiting..."
            sleep 2
          done

      - name: 🏥 Health check
        run: |
          response=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3000)
          if [ $response -eq 200 ]; then
            echo "✅ Health check passed (HTTP $response)"
          else
            echo "❌ Health check failed (HTTP $response)"
            exit 1
          fi

  # 프로덕션 환경 배포
  deploy-prod:
    name: 🌟 Deploy to Production
    runs-on: self-hosted
    needs: [test, build, security-scan]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment:
      name: production
      url: http://localhost:8080
    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4

      - name: 📥 Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp

      - name: 📥 Load Docker image
        run: docker load --input /tmp/docker-image.tar

      - name: 🏷️ Tag for production
        run: |
          docker tag ${{ env.DOCKER_IMAGE_NAME }}:latest ${{ env.DOCKER_IMAGE_NAME }}:prod-$(date +%Y%m%d-%H%M%S)
          docker tag ${{ env.DOCKER_IMAGE_NAME }}:latest ${{ env.DOCKER_IMAGE_NAME }}:prod-latest

      - name: 🛑 Stop existing container
        run: |
          if docker ps -q --filter "name=docker-hello-app-prod" | grep -q .; then
            echo "Stopping existing production container..."
            docker stop docker-hello-app-prod
            docker rm docker-hello-app-prod
          fi

      - name: 🚀 Deploy to production
        run: |
          docker run -d \
            --name docker-hello-app-prod \
            --restart unless-stopped \
            -p 8080:3000 \
            -e NODE_ENV=production \
            -e PORT=3000 \
            ${{ env.DOCKER_IMAGE_NAME }}:prod-latest

      - name: ⏳ Wait for application startup
        run: |
          echo "Waiting for production application to start..."
          for i in {1..30}; do
            if curl -f http://localhost:8080 > /dev/null 2>&1; then
              echo "Production application is ready!"
              break
            fi
            echo "Attempt $i: Production application not ready yet, waiting..."
            sleep 2
          done

      - name: 🏥 Production health check
        run: |
          response=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080)
          if [ $response -eq 200 ]; then
            echo "✅ Production health check passed (HTTP $response)"
          else
            echo "❌ Production health check failed (HTTP $response)"
            exit 1
          fi

      - name: 🧹 Cleanup old images
        run: |
          echo "Cleaning up old Docker images..."
          docker image prune -f
          # 7일 이상 된 production 이미지 삭제
          docker images ${{ env.DOCKER_IMAGE_NAME }} --format "table {{.Repository}}:{{.Tag}}\t{{.CreatedAt}}" | \
            grep "prod-" | \
            awk '$2 < "'$(date -d '7 days ago' '+%Y-%m-%d')'" {print $1}' | \
            xargs -r docker rmi

  # 배포 알림
  notify:
    name: 📢 Deployment Notification
    runs-on: self-hosted
    needs: [deploy-dev, deploy-prod]
    if: always()
    steps:
      - name: 📢 Send notification
        run: |
          if [ "${{ needs.deploy-dev.result }}" == "success" ] || [ "${{ needs.deploy-prod.result }}" == "success" ]; then
            echo "✅ Deployment completed successfully!"
            echo "Development: ${{ needs.deploy-dev.result }}"
            echo "Production: ${{ needs.deploy-prod.result }}"
          else
            echo "❌ Deployment failed!"
            echo "Development: ${{ needs.deploy-dev.result }}"
            echo "Production: ${{ needs.deploy-prod.result }}"
          fi

      - name: 📊 Deployment summary
        run: |
          echo "## 🚀 Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | Status | URL |" >> $GITHUB_STEP_SUMMARY
          echo "|-------------|--------|-----|" >> $GITHUB_STEP_SUMMARY
          echo "| Development | ${{ needs.deploy-dev.result }} | http://localhost:3000 |" >> $GITHUB_STEP_SUMMARY
          echo "| Production | ${{ needs.deploy-prod.result }} | http://localhost:8080 |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY